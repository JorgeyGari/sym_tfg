\chapter{Methods and Algorithms}\label{chap:appendix-a}

\begin{lstlisting}[caption={The implementation of \texttt{PartialEq} for the \texttt{Variable} struct}, label={lst:variable-eq}]
    impl PartialEq for Variable {
        fn eq(&self, other: &Self) -> bool {
            self.name == other.name && self.degree == other.degree
        }
    }
\end{lstlisting}

\begin{minipage}{\linewidth}
    \begin{lstlisting}[caption={The implementation of the \texttt{sort\_vars()} method for the \texttt{Term} struct}, label={lst:term-sort-vars}]
        /// Sorts the variables in the term in ascending order based on their names.
        pub fn sort_vars(&mut self) {
            self.variables.sort_by(|a, b| a.name.cmp(&b.name));
        }
    \end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
    \begin{lstlisting}[caption={The implementation of the \texttt{max\_degree()} method for the \texttt{Term} struct}, label={lst:term-max-degree}]
        /// Find max degree of the variables in the term.
        pub fn max_degree(&self) -> Rational64 {
            self.variables
                .iter()
                .map(|v| v.degree)
                .max()
                .unwrap_or(0.into())
        }
    \end{lstlisting}
\end{minipage}

\begin{lstlisting}[caption={The implementation of the \texttt{factor()} method for the \texttt{Term} struct}, label={lst:term-factor}]
    /// Factors the term by combining like variables.
    pub fn factor(&mut self) {
        let mut new_vars: Vec<Variable> = Vec::new();
        for var1 in &self.variables {
            let mut found = false;
            for var2 in &mut new_vars {
                if var1.name == var2.name {
                    var2.degree += var1.degree;
                    found = true;
                    break;
                }
            }
            if !found {
                new_vars.push(var1.clone());
            }
        }
        new_vars.retain(|v| v.degree != 0.into());
        self.variables = new_vars;
    }
\end{lstlisting}

\begin{minipage}{\linewidth}
    \begin{lstlisting}[caption={The implementation of the \texttt{invert()} method for the \texttt{Term} struct}, label={lst:term-invert}]
        /// Inverts the term.
        pub fn invert(&mut self) {
            self.coefficient = Rational64::new(*self.coefficient.denom(), *self.coefficient.numer());
            for var in &mut self.variables {
                var.degree *= -1;
            }
        }
    \end{lstlisting}
\end{minipage}

\begin{lstlisting}[caption={The implementation of the \texttt{pow()} method for the \texttt{Term} struct}, label={lst:term-pow}]
    /// Returns a polynomial containing the term to the power of q.
    pub fn pow(&self, q: Rational64) -> Polynomial {
        let mut new_vars: Vec<Variable> = Vec::new();
        for var in &self.variables {
            new_vars.push(Variable {
                name: var.name.clone(),
                degree: var.degree * q.clone(),
            });
        }
        let mut ratio_coef =
            Rational64::from_f64(self.coefficient.to_f64().unwrap().powf(q.to_f64().unwrap()))
                .unwrap();
        if self.coefficient.denom() == &1 && ratio_coef.denom() != &1 {
            // Don't convert expressions like sqrt(13) to a ratio
            return Polynomial {
                terms: vec![self.clone()],
                degree: q,
            };
        }
        Polynomial {
            terms: vec![Term {
                coefficient: ratio_coef,
                variables: new_vars,
            }],
            degree: 1.into(),
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of \texttt{PartialEq} for the \texttt{Term} struct}, label={lst:term-eq}]
    impl PartialEq for Term {
        fn eq(&self, other: &Self) -> bool {
            self.coefficient == other.coefficient
                && {
                    let mut self_vars = self.variables.clone();
                    let mut other_vars = other.variables.clone();
                    self_vars.sort();
                    other_vars.sort();
                    self_vars == other_vars
                }
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the multiplication operation for the \texttt{Term} struct}, label={lst:term-mul}]
    impl Mul for Term {
        type Output = Term;
        fn mul(self, other: Self) -> Term {
            let mut result = Vec::new();
            let mut new_vars = self.variables.clone();
            new_vars.extend(other.variables.clone());
            let mut new_term = Term {
                coefficient: self.coefficient * other.coefficient,
                variables: new_vars,
            };
            new_term.sort_vars();
            new_term.factor();
            result.push(new_term);
            let mut product = Polynomial {
                terms: result,
                degree: 1.into(),
            };
            product.simplify();
            product.terms[0].clone()
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the division operation for the \texttt{Term} struct}, label={lst:term-div}]
    impl Div for Term {
        type Output = Polynomial;
        fn div(self, other: Self) -> Polynomial {
            let dividend = Polynomial {
                terms: vec![self],
                degree: 1.into(),
            };
            let divisor = Polynomial {
                terms: vec![other],
                degree: 1.into(),
            };
            let mut result = Vec::new();
            for term1 in &dividend.terms {
                for term2 in &divisor.terms {
                    let mut new_vars = term2.variables.clone();
                    for var in &mut new_vars {
                        var.degree *= -1;
                    }
                    new_vars.extend(term1.variables.clone());
                    let mut new_term = Term {
                        coefficient: term1.coefficient / term2.coefficient,
                        variables: new_vars,
                    };
                    new_term.sort_vars();
                    new_term.factor();
                    result.push(new_term);
                }
            }
            let mut quotient = Polynomial {
                terms: result,
                degree: 1.into(),
            };
            quotient.simplify();
            quotient
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{degree()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-degree}]
    /// Return the degree of the polynomial.
    pub fn degree(&self) -> Rational64 {
        self.terms
            .iter()
            .map(|t| t.max_degree())
            .max()
            .unwrap_or(0.into())
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{leading\_term()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-leading-term}]
    /// Return the leading term of the polynomial.
    pub fn leading_term(&self) -> Term {
        let mut max_degree = Rational64::new(0, 1);
        let mut leading_term = Term {
            coefficient: Rational64::new(0, 1),
            variables: Vec::new(),
        };
        for term in &self.terms {
            let degree = term.max_degree();
            if degree >= max_degree {
                max_degree = degree;
                leading_term = term.clone();
            }
        }
        leading_term
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{evaluate()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-evaluate}]
    /// Evaluate the polynomial at a given value for the variables.
    pub fn evaluate(&mut self, values: &Vec<(String, Rational64)>) {
        let mut result = Polynomial {
            terms: Vec::new(),
            degree: 1.into(),
        };
        for term in &self.terms {
            let mut new_term = term.clone();
            for var in &mut new_term.variables {
                if let Some(val) = values.iter().find(|(name, _)| name == &var.name) {
                    let value = *val.1.clone().numer() as f64 / *val.1.denom() as f64;
                    let expon = *var.degree.numer() as f64 / *var.degree.denom() as f64;
                    new_term.coefficient =
                        new_term.coefficient * Rational64::from_f64(value.powf(expon)).unwrap();
                    var.degree = 0.into(); // Set the degree of the variable to 0, essentially removing it from the term
                }
            }
            result.terms.push(new_term);
        }
        *self = result;
        self.simplify();
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{sort\_terms()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-sort-terms}]
    /// Sorts the terms in the polynomial in descending order based on the max degree of the variables in each term, then by alphabetical order.
    pub fn sort_terms(&mut self) -> () {
        self.terms.sort_by(|a, b| {
            let max_degree_cmp = b
                .variables
                .iter()
                .map(|v| v.degree)
                .max()
                .unwrap_or(0.into())
                .cmp(
                    &a.variables
                        .iter()
                        .map(|v| v.degree)
                        .max()
                        .unwrap_or(0.into()),
                );
            if max_degree_cmp != Ordering::Equal {
                return max_degree_cmp;
            }
            a.variables.cmp(&b.variables)
        });
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{as\_string()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-as-string}]
    /// Converts the polynomial to a string in a pretty format.
    pub fn as_string(&self) -> String {
        let mut result = String::new();
        for (i, term) in self.terms.iter().enumerate() {
            if term.coefficient == Rational64::new(0, 1) && self.terms.len() > 1 {
                continue;
            }
            if i != 0 && term.coefficient > Rational64::new(0, 1) {
                result.push_str("+");
            }
            if term.variables.is_empty() || term.coefficient != Rational64::new(1, 1) {
                if term.coefficient == Rational64::new(-1, 1) && !term.variables.is_empty() {
                    result.push_str("-");
                } else {
                    result.push_str(&term.coefficient.to_string());
                }
            }
            for variable in &term.variables {
                result.push_str(&variable.name);
                if variable.degree != 1.into() {
                    result.push_str(&format!("^({})", variable.degree));
                }
            }
        }
        if self.degree != 1.into() {
            result = format!("({})^({})", result, self.degree);
        }
        result
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{add\_like\_terms()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-add-like-terms}]
    /// Adds like terms in the polynomial.
    pub fn add_like_terms(&mut self) -> () {
        let mut new_terms: Vec<Term> = Vec::new();

        for term in &self.terms {
            let coeff: Rational64 = term.coefficient.clone();
            let mut found = false;

            for term1 in &mut new_terms {
                if term1.variables == term.variables {
                    term1.coefficient += term.coefficient;
                    found = true;
                    break;
                }
            }

            if !found {
                new_terms.push(Term {
                    coefficient: coeff,
                    variables: term.variables.clone(),
                });
            }
        }

        self.terms = new_terms;
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{simplify()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-simplify}]
    /// Simplifies the polynomial by sorting the terms, sorting the variables in each term, factoring each term, and adding like terms.
    pub fn simplify(&mut self) -> () {
        let d: Option<f64> = self.degree.to_f64();
        // println!("Degree: {:?}", d);
        if d.is_some() {
            if self.terms.len() == 1 {
                let exp = Rational64::from_f64(d.unwrap());
                let powered = self.terms[0].pow(exp.unwrap());
                self.terms = powered.terms;
                self.degree = powered.degree;
            } else if d.unwrap().fract() == 0.0 && d.unwrap() >= 2.0 {
                for _i in 1..d.unwrap() as i64 {
                    *self = self.clone() * self.clone();
                }
                self.degree = 1.into();
            }
        }
        // println!("Simplifying 1: {}", self.as_string());

        for term in &mut self.terms {
            term.sort_vars();
        }

        for term in &mut self.terms {
            term.factor();
        }

        self.add_like_terms();

        // Filter to remove terms with coefficient 0
        self.terms
            .retain(|term| term.coefficient != Rational64::new(0, 1));

        // Add a term with coefficient 0 if all terms were removed
        if self.terms.is_empty() {
            self.terms.push(Term {
                coefficient: Rational64::new(0, 1),
                variables: vec![],
            });
        }

        self.sort_terms();
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{make\_integer()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-make-integer}]
    /// Multiplies the polynomial by the smallest scalar such that all coefficients are integers. Returns the scalar.
    pub fn make_integer(&mut self) -> i64 {
        // Get the lcm of the denominators of the coefficients
        let mut lcm = 1;
        for term in &self.terms {
            let denom = term.coefficient.denom();
            lcm = num_integer::lcm(lcm as i64, *denom);
        }
        // Multiply each coefficient by the lcm
        for term in &mut self.terms {
            term.coefficient *= Rational64::new(lcm, 1);
        }
        lcm
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{factor()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-factor}]
    /// Finds the greatest common divisor of the coefficients of the terms in a single-variable polynomial with integer coefficients. Returns the gcd and the polynomial with the gcd factored out.
    pub fn factor(&mut self) -> (Term, Polynomial) {
        if self.degree != 1.into() {
            return (
                Term {
                    coefficient: Rational64::new(1, 1),
                    variables: vec![],
                },
                self.clone(),
            ); // Only works for degree 1 polynomials
        }
        let mut factored_out = Term {
            coefficient: Rational64::new(1, 1),
            variables: vec![],
        };
        let mut factored = self.clone();

        // Find the gcd of the coefficients
        let mut gcd = self.terms[0].coefficient.numer().abs();
        for term in &self.terms {
            gcd = num_integer::gcd(gcd, term.coefficient.numer().abs());
        }
        factored_out.coefficient = Rational64::new(gcd, 1);

        // Check the name of the variable that appears in all terms
        let mut seen_vars = vec![];
        for var in &self.terms[0].variables {
            seen_vars.push(var.name.clone());
        }
        for term in &self.terms {
            let mut curr_vars = vec![];
            for var in &term.variables {
                curr_vars.push(var.name.clone());
            }
            seen_vars = seen_vars
                .iter()
                .map(|x| x.clone())
                .filter(|x| curr_vars.contains(x))
                .collect();

            if seen_vars.len() == 0 {
                if gcd != 0 {
                    for term in &mut factored.terms {
                        term.coefficient *= Rational64::new(1, gcd);
                    }
                }
                return (factored_out, factored);
            }
        }
        let var_name = seen_vars[0].clone(); // Always the first element

        // Make the coefficients integers
        let mut p = self.clone();
        let adjust = p.make_integer();
        p.simplify();

        // Find the gcd of the coefficients
        let mut gcd = p.terms[0].coefficient.numer().abs();
        for term in &p.terms {
            gcd = num_integer::gcd(gcd, term.coefficient.numer().abs());
        }

        // Find the smallest power of the variable that appears in all terms
        let mut min_degree = p.terms[0].variables[0].degree;
        for term in &p.terms {
            for var in &term.variables {
                if var.degree < min_degree && var.degree > 0.into() {
                    min_degree = var.degree;
                }
            }
        }

        // Factor out the gcd
        factored_out.coefficient = Rational64::new(gcd, 1);
        factored_out.variables.push(Variable {
            name: var_name,
            degree: min_degree,
        });

        let mut inv: Term = factored_out.clone();
        inv.invert();
        factored = factored
            * Polynomial {
                terms: vec![inv],
                degree: 1.into(),
            };

        // Undo the scaling of the coefficients
        for term in &mut factored.terms {
            term.coefficient *= Rational64::new(1, adjust);
        }
        factored_out.coefficient *= Rational64::new(1, adjust);

        factored.simplify();

        return (factored_out, factored);
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{first\_var()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-first-var}]
    /// Returns the name of the first variable in the polynomial.
    pub fn first_var(&self) -> Option<String> {
        if self.terms.len() == 0 {
            panic!("Polynomial has no terms!");
        } else if self.terms[0].variables.len() == 0 {
            return None;
        } else {
            return Some(self.terms[0].variables[0].name.clone());
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{find\_sym\_coeff()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-find-sym-coeff}]
    /// Find symbolic coefficient by degree.
    pub fn find_sym_coeff(&self, var: &str, degree: Rational64) -> (Term, Term) {
            let zero = Term {
                coefficient: Rational64::new(0, 1),
                variables: vec![],
                };
                let term = self
                .terms
                .iter()
                .find(|t| {
                    t.variables
                    .iter()
                    .any(|v| v.name == var && v.degree == degree)
                    })
                    .unwrap_or_else(|| &zero)
                    .clone();
                    let sym_coeff = Term {
                        coefficient: term.coefficient.clone(),
                        variables: term
                    .variables
                    .iter()
                    .filter(|v| v.name != var)
                    .cloned()
                    .collect(),
            };
            return (term, sym_coeff);
            }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{roots()} method for the \texttt{Polynomial} struct}, label={lst:polynomial-roots}]
    /// Finds the roots (numerical or symbolic) of the polynomial.
    pub fn roots(&self, var: &str) -> Vec<Vec<PolyRatio>> {
        let mut result = vec![Vec::new()];
        let mut self_copy = self.clone();
        self_copy.simplify();

        // Find out the degree of the polynomial, but only taking into account the variable var
        let degree = self_copy
            .terms
            .iter()
            .map(|t| {
                t.variables
                    .iter()
                    .find(|v| v.name == var)
                    .map(|v| v.degree)
                    .unwrap_or(0.into())
            })
            .max()
            .unwrap_or(0.into());

        match degree {
            d if d == 1.into() => {
                let (a_term, a) = self_copy.find_sym_coeff(var, 1.into());
                let b = self.clone()
                    - Polynomial {
                        terms: vec![a_term],
                        degree: 1.into(),
                    };

                let minus_b = PolyRatio::from(b)
                    * PolyRatio::from(Polynomial {
                        terms: vec![Term {
                            coefficient: Rational64::new(-1, 1),
                            variables: vec![],
                        }],
                        degree: 1.into(),
                    });
                let root = minus_b
                    / PolyRatio::from(Polynomial {
                        terms: vec![a],
                        degree: 1.into(),
                    });
                result.push(vec![root]);
            }
            d if d == 2.into() => {
                // Find the term with x^2 by filtering the terms with the variable x and degree 2
                let (a_term, a) = self.find_sym_coeff(var, 2.into());
                let (b_term, b) = self.find_sym_coeff(var, 1.into());
                let c: Polynomial = self.clone()
                    - Polynomial {
                        terms: vec![a_term.clone(), b_term.clone()],
                        degree: 1.into(),
                    };
                let minus_b = PolyRatio::from(Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(-1, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                }) * PolyRatio::from(Polynomial {
                    terms: vec![b.clone()],
                    degree: 1.into(),
                });
                let mut b_squared = PolyRatio::from(Polynomial {
                    terms: vec![b.clone()],
                    degree: 2.into(),
                });
                b_squared.simplify();
                let four_ac = PolyRatio::from(Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(4, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                }) * PolyRatio::from(Polynomial {
                    terms: vec![a.clone()],
                    degree: 1.into(),
                }) * c.clone();
                let discriminant = b_squared.clone() - four_ac.clone();
                let mut sqrt_discriminant = discriminant.clone();
                if (discriminant.numerator.terms[0].coefficient < 0.into())
                    ^ (discriminant.denominator.terms[0].coefficient < 0.into())
                {
                    sqrt_discriminant = discriminant.clone()
                        * PolyRatio::from(Polynomial {
                            terms: vec![Term {
                                coefficient: Rational64::new(-1, 1),
                                variables: vec![],
                            }],
                            degree: 1.into(),
                        })
                        * PolyRatio::from(Polynomial {
                            terms: vec![Term {
                                coefficient: Rational64::new(1, 1),
                                variables: vec![Variable {
                                    name: "\u{2148}".to_string(),
                                    degree: Rational64::new(2, 1),
                                }],
                            }],
                            degree: 1.into(),
                        });
                    println!("(\u{2148} is the imaginary unit)");
                }
                sqrt_discriminant.numerator.degree = Rational64::new(1, 2);
                sqrt_discriminant.denominator.degree = Rational64::new(1, 2);
                sqrt_discriminant.simplify();
                let two_a = PolyRatio::from(Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(2, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                }) * PolyRatio::from(Polynomial {
                    terms: vec![a.clone()],
                    degree: 1.into(),
                });
                if sqrt_discriminant.numerator.degree != Rational64::new(1, 1) {
                    let root1 = vec![
                        minus_b.clone() / two_a.clone(),
                        sqrt_discriminant.clone() / two_a.clone(),
                    ];
                    let root2 = vec![
                        minus_b.clone() / two_a.clone(),
                        sqrt_discriminant.clone()
                            / (PolyRatio::from(Polynomial {
                                terms: vec![Term {
                                    coefficient: Rational64::new(-1, 1),
                                    variables: vec![],
                                }],
                                degree: 1.into(),
                            }) * two_a.clone()),
                    ];
                    result.push(root1);
                    result.push(root2);
                } else {
                    let root1 = (minus_b.clone() + sqrt_discriminant.clone()) / two_a.clone();
                    let root2 = (minus_b - sqrt_discriminant) / two_a;
                    result.push(vec![root1]);
                    result.push(vec![root2]);
                }
            }
            _ => {
                panic!("Higher degree polynomials not supported!");
            }
        }
        return result;
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of \texttt{PartialEq} for the \texttt{Polynomial} struct}, label={lst:polynomial-eq}]
    impl PartialEq for Polynomial {
        fn eq(&self, other: &Self) -> bool {
            let mut self_copy = self.clone();
            self_copy.simplify();
            let mut other_copy = other.clone();
            other_copy.simplify();
            self_copy.terms == other_copy.terms
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the addition operation for the \texttt{Polynomial} struct}, label={lst:polynomial-add}]
    impl Add for Polynomial {
        type Output = Self;
    
        fn add(self, other: Self) -> Self {
            let mut result = self.terms.clone();
            result.extend(other.terms);
            let mut sum = Polynomial {
                terms: result,
                degree: 1.into(),
            };
            sum.simplify();
            sum
        }
    }        
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the subtraction operation for the \texttt{Polynomial} struct}, label={lst:polynomial-sub}]
    impl Sub for Polynomial {
        type Output = Self;
    
        fn sub(self, mut other: Self) -> Self {
            for term in &mut other.terms {
                term.coefficient *= -1;
            }
    
            self.add(other)
        }
    }        
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the multiplication operation for the \texttt{Polynomial} struct}, label={lst:polynomial-mul}]
    impl Mul for Polynomial {
        type Output = Self;
    
        fn mul(self, other: Self) -> Self {
            let mut result = Vec::new();
            if other
                == (Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(1, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                })
            {
                return self;
            }
            for term1 in &self.terms {
                for term2 in &other.terms {
                    let mut new_vars = term1.variables.clone();
                    new_vars.extend(term2.variables.clone());
                    let mut new_term = Term {
                        coefficient: term1.coefficient * term2.coefficient,
                        variables: new_vars,
                    };
                    new_term.sort_vars();
                    new_term.factor();
                    result.push(new_term);
                }
            }
            let mut product = Polynomial {
                terms: result,
                degree: 1.into(),
            };
            product.simplify();
            product
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the division operation for the \texttt{Polynomial} struct}, label={lst:polynomial-div}]
    impl Div for Polynomial {
        type Output = PolyRatio;
        fn div(self, other: Self) -> PolyRatio {
            let mut dividend = self.clone();
            dividend.simplify();
    
            if dividend.terms.len() == 0 {
                return PolyRatio::from(Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(0, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                });
            }
    
            let mut divisor = other.clone();
            divisor.simplify();
    
            let mut quotient = Polynomial {
                terms: vec![],
                degree: 1.into(),
            };
    
            let mut remainder = dividend.clone();
    
            let zero_poly = Polynomial {
                terms: vec![Term {
                    coefficient: Rational64::new(0, 1),
                    variables: vec![],
                }],
                degree: 1.into(),
            };
    
            if remainder.degree() < divisor.degree() {
                return PolyRatio {
                    numerator: remainder,
                    denominator: divisor,
                };
            }
    
            while remainder != zero_poly
                && remainder.terms.len() != 0
                && remainder.degree() >= divisor.degree()
            {
                let t = remainder.leading_term() / divisor.leading_term();
                quotient = quotient + t.clone();
                remainder = remainder - (divisor.clone() * t.clone());
                remainder.simplify();
            }
    
            quotient.simplify();
            let ratio = PolyRatio::from(quotient);
            ratio
        }
    }
\end{lstlisting}        

\begin{lstlisting}[caption={The implementation of the \texttt{simplify()} method for the \texttt{PolyRatio} struct}, label={lst:polyratio-simplify}]
    pub fn simplify(&mut self) {
        self.numerator.simplify();
        self.denominator.simplify();

        // Make the coefficients integers
        let mut n = self.numerator.clone();
        let mut d = self.denominator.clone();
        let adjust_n = n.make_integer();
        let adjust_d = d.make_integer();

        // Find the smallest negative exponent of each variable in the denominator
        let mut vars_to_move: Vec<Variable> = vec![];
        for term in &d.terms {
            for var in &term.variables {
                if var.degree < 0.into() {
                    vars_to_move.push(var.clone());
                }
            }
        }
        for var in &mut vars_to_move {
            var.degree *= -1;
        }

        // Multiply the numerator and denominator by the accumulated terms
        n = n * Polynomial {
            terms: vec![Term {
                coefficient: Rational64::new(1, 1),
                variables: vars_to_move.clone(),
            }],
            degree: 1.into(),
        };
        d = d * Polynomial {
            terms: vec![Term {
                coefficient: Rational64::new(1, 1),
                variables: vars_to_move.clone(),
            }],
            degree: 1.into(),
        };

        // Find the smallest negative exponent of each variable in the denominator
        let mut vars_to_move: Vec<Variable> = vec![];
        for term in &n.terms {
            for var in &term.variables {
                if var.degree < 0.into() {
                    vars_to_move.push(var.clone());
                }
            }
        }
        for var in &mut vars_to_move {
            var.degree *= -1;
        }

        // Multiply the numerator and denominator by the accumulated terms
        n = n * Polynomial {
            terms: vec![Term {
                coefficient: Rational64::new(1, 1),
                variables: vars_to_move.clone(),
            }],
            degree: 1.into(),
        };
        d = d * Polynomial {
            terms: vec![Term {
                coefficient: Rational64::new(1, 1),
                variables: vars_to_move.clone(),
            }],
            degree: 1.into(),
        };

        // Factor out as much as possible from the numerator and denominator
        let (t1, mut n) = n.factor();
        let (t2, mut d) = d.factor();

        // We are going to divide the numerator and denominator, these are the values by default
        let mut var_name = "".to_string();
        let mut min_degree = 0.into();

        // If the factored out terms share a variable
        if t1.variables.len() != 0 && t2.variables.len() != 0 {
            if t1.variables[0].name == t2.variables[0].name {
                var_name = t1.variables[0].name.clone();
                min_degree = t1.variables[0].degree.min(t2.variables[0].degree);
            }
        }

        let gcd_term = Term {
            // The term that will be canceled out in the numerator and denominator
            coefficient: Rational64::from_integer(num_integer::gcd(
                t1.coefficient.numer().abs(),
                t2.coefficient.numer().abs(),
            )),
            variables: if var_name != "" {
                // If the terms share a variable
                vec![Variable {
                    name: var_name,
                    degree: min_degree,
                }]
            } else {
                vec![]
            },
        };

        n = n * Polynomial {
            terms: vec![t1.clone()],
            degree: 1.into(),
        };

        d = d * Polynomial {
            terms: vec![t2],
            degree: 1.into(),
        };

        // Cancel out the gcd from the numerator and denominator
        let mut inv = gcd_term.clone();
        inv.invert();
        n = n * Polynomial {
            terms: vec![inv.clone()],
            degree: 1.into(),
        };
        d = d * Polynomial {
            terms: vec![inv],
            degree: 1.into(),
        };

        // Undo the scaling of the coefficients
        for term in &mut n.terms {
            term.coefficient *= Rational64::new(1, adjust_n);
        }
        for term in &mut d.terms {
            term.coefficient *= Rational64::new(1, adjust_d);
        }

        self.numerator = n;
        self.denominator = d;

        self.numerator.simplify();
        self.denominator.simplify();

        if self.denominator == self.numerator {
            self.numerator = Polynomial {
                terms: vec![Term {
                    coefficient: Rational64::new(1, 1),
                    variables: vec![],
                }],
                degree: 1.into(),
            };
            self.denominator = Polynomial {
                terms: vec![Term {
                    coefficient: Rational64::new(1, 1),
                    variables: vec![],
                }],
                degree: 1.into(),
            };
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{as\_string()} method for the \texttt{PolyRatio} struct}, label={lst:polyratio-as-string}]
    pub fn as_string(&self) -> String {
        if self.denominator.as_string() == "1".to_string() {
            self.numerator.as_string()
        } else if self.denominator.as_string() == "0".to_string() {
            "ERROR: Division by zero!".to_string()
        } else {
            format!(
                "({}) / ({})",
                self.numerator.as_string(),
                self.denominator.as_string()
            )
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{evaluate()} method for the \texttt{PolyRatio} struct}, label={lst:polyratio-evaluate}]
    pub fn evaluate(&mut self, values: &Vec<(String, Rational64)>) {
        self.numerator.evaluate(values);
        self.denominator.evaluate(values);
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the addition operation for the \texttt{PolyRatio} struct}, label={lst:polyratio-add}]
    impl Add for PolyRatio {
        type Output = Self;
    
        fn add(self, other: Self) -> Self {
            let mut result = PolyRatio {
                numerator: self.numerator.clone() * other.denominator.clone()
                    + other.numerator.clone() * self.denominator.clone(),
                denominator: self.denominator.clone() * other.denominator.clone(),
            };
            result.simplify();
            result
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the subtraction operation for the \texttt{PolyRatio} struct}, label={lst:polyratio-sub}]
    impl Sub for PolyRatio {
        type Output = Self;
    
        fn sub(self, other: Self) -> Self {
            let mut result = PolyRatio {
                numerator: self.numerator.clone() * other.denominator.clone()
                    - other.numerator.clone() * self.denominator.clone(),
                denominator: self.denominator.clone() * other.denominator.clone(),
            };
            result.simplify();
            result
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the multiplication operation for the \texttt{PolyRatio} struct}, label={lst:polyratio-mul}]
    impl Mul for PolyRatio {
        type Output = Self;
    
        fn mul(self, other: Self) -> Self {
            let mut result = PolyRatio {
                numerator: self.numerator.clone() * other.numerator.clone(),
                denominator: self.denominator.clone() * other.denominator.clone(),
            };
            result.simplify();
            result
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the division operation for the \texttt{PolyRatio} struct}, label={lst:polyratio-div}]
    impl Div for PolyRatio {
        type Output = Self;
    
        fn div(self, other: Self) -> Self {
            let mut result = PolyRatio {
                numerator: self.numerator.clone() * other.denominator.clone(),
                denominator: self.denominator.clone() * other.numerator.clone(),
            };
            result.simplify();
            result
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{from()} function for the \texttt{PolyRatio} struct}, label={lst:polyratio-from}]
    impl From<Polynomial> for PolyRatio {
        fn from(p: Polynomial) -> Self {
            PolyRatio {
                numerator: p,
                denominator: Polynomial {
                    terms: vec![Term {
                        coefficient: Rational64::new(1, 1),
                        variables: vec![],
                    }],
                    degree: 1.into(),
                },
            }
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the addition operation between \texttt{Polynomial} and \texttt{PolyRatio}}, label={lst:polyratio-polynomial-add}]
    impl Add<PolyRatio> for Polynomial {
        type Output = PolyRatio;
    
        fn add(self, other: PolyRatio) -> PolyRatio {
            let upgraded_self = PolyRatio::from(self);
            upgraded_self + other
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the subtraction operation between \texttt{Polynomial} and \texttt{PolyRatio}}, label={lst:polyratio-polynomial-sub}]
    impl Sub<PolyRatio> for Polynomial {
        type Output = PolyRatio;
    
        fn sub(self, other: PolyRatio) -> PolyRatio {
            let upgraded_self = PolyRatio::from(self);
            upgraded_self - other
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the multiplication operation between \texttt{Polynomial} and \texttt{PolyRatio}}, label={lst:polyratio-polynomial-mul}]
    impl Mul<PolyRatio> for Polynomial {
        type Output = PolyRatio;
    
        fn mul(self, other: PolyRatio) -> PolyRatio {
            let upgraded_self = PolyRatio::from(self);
            upgraded_self * other
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the division operation between \texttt{Polynomial} and \texttt{PolyRatio}}, label={lst:polyratio-polynomial-div}]
    impl Div<PolyRatio> for Polynomial {
        type Output = PolyRatio;
    
        fn div(self, other: PolyRatio) -> PolyRatio {
            let upgraded_self = PolyRatio::from(self);
            upgraded_self / other
        }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{variable\_from\_string()} function}, label={lst:variable-from-string}]
    fn variable_from_string(var: &str) -> polynomial::Variable {
        let mut iter = var.split('^');
        let name = iter.next().unwrap().to_string();
        let degree = iter
            .next()
            .map(|d| {
                let clean = d.replace("(", "").replace(")", "");
                if d.contains('/') {
                    let parts: Vec<&str> = clean.split('/').collect();
                    let numerator = parts[0].trim().parse::<i64>().unwrap_or(1);
                    let denominator = parts[1].trim().parse::<i64>().unwrap_or(1);
                    Rational64::new(numerator, denominator)
                } else if d.contains('.') {
                    let parts: Vec<&str> = clean.split('.').collect();
                    let numerator = clean.replace(".", "").trim().parse::<i64>().unwrap_or(1);
                    let denominator = 10_i64.pow(parts[1].len() as u32);
                    Rational64::new(numerator, denominator)
                } else {
                    clean.trim().parse::<i64>().unwrap_or(1).into()
                }
            })
            .unwrap_or(1.into());
        polynomial::Variable { name, degree }
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{parse\_polynomial()} function}, label={lst:parse-polynomial}]
    fn parse_polynomial(expression: Pairs<Rule>) -> polynomial::Polynomial {
        let mut p = polynomial::Polynomial {
            terms: Vec::new(),
            degree: 1.into(),
        };
        for part in expression {
            match part.as_rule() {
                Rule::term => {
                    let mut term = polynomial::Term {
                        coefficient: Rational64::new(1, 1),
                        variables: Vec::new(),
                    };
                    for factor in part.into_inner() {
                        match factor.as_rule() {
                            Rule::sign => {
                                if factor.as_str() == "-" {
                                    term.coefficient *= -1;
                                }
                            }
                            Rule::number => {
                                term.coefficient *=
                                    factor.as_str().trim().parse::<Rational64>().unwrap();
                            }
                            Rule::fraction => {
                                let mut iter = factor.into_inner();
                                let numerator =
                                    iter.next().unwrap().as_str().trim().parse::<i64>().unwrap();
                                let denominator =
                                    iter.next().unwrap().as_str().trim().parse::<i64>().unwrap();
                                term.coefficient *= Rational64::new(numerator, denominator);
                            }
                            Rule::var => {
                                let variable = variable_from_string(factor.as_str());
                                term.variables.push(variable);
                            }
                            Rule::EOI => (),
                            _ => unreachable!(),
                        }
                    }
                    p.terms.push(term);
                }
                Rule::EOI => (),
                _ => unreachable!(),
            }
        }
        p
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{parse\_assignment()} function}, label={lst:parse-assignment}]
    fn parse_assignment(assignment: Pairs<Rule>) -> (String, Rational64) {
        // Only assigning Rational64 values?
        let mut iter = assignment;
        let var_name = iter.next().unwrap().as_str().to_string();
        let var_value = iter
            .next()
            .unwrap()
            .as_str()
            .trim()
            .parse::<Rational64>()
            .unwrap();
        (var_name, var_value)
    }
\end{lstlisting}

\begin{lstlisting}[caption={The implementation of the \texttt{parse\_operation()} function}, label={lst:parse-operation}]
    fn parse_operation(operation: Pairs<Rule>) -> polynomial::PolyRatio {
        let mut iter = operation;
        let first_poly = parse_polynomial(iter.next().unwrap().into_inner());
        let mut result = PolyRatio::from(first_poly);
    
        while let Some(op) = iter.next() {
            let next_poly = parse_polynomial(iter.next().unwrap().into_inner());
            match op.as_rule() {
                Rule::add => result = result + next_poly,
                Rule::sub => result = result - next_poly,
                Rule::mul => result = result * next_poly,
                Rule::div => result = result / next_poly,
                _ => unreachable!(),
            }
        }
        result
    }        
\end{lstlisting}

\begin{lstlisting}[caption={Reading and parsing user input, and defining storage for custom variable values}, label={lst:reading-parsing-input}]
    let unparsed_file = fs::read_to_string("input.txt").unwrap();

    let file = PolyParser::parse(Rule::file, &unparsed_file)
    .expect("unsuccessful parse")
    .next()
    .unwrap();

    let mut var_values: Vec<(String, Rational64)> = Vec::new();
\end{lstlisting}

\begin{lstlisting}[caption={Iterating through the lines of the input file}, label={lst:iterating-input}]
    for line in file.into_inner() {
    if line.as_str().trim().is_empty() {
        continue; // Skip empty lines
    }
    println!("{}", line.as_str());
    match line.as_rule() {
        Rule::assign => {
            let (var_name, var_value) = parse_assignment(line.into_inner());
            var_values.push((var_name.clone(), var_value));

            println!("\t{} = {}", var_name, var_value);
        }
        Rule::polynomial => {
            let mut p = parse_polynomial(line.into_inner());
            p.evaluate(&var_values);
            println!("\t{}", p.as_string());
        }
        Rule::operation => {
            let mut result = parse_operation(line.into_inner());
            result.evaluate(&var_values);
            println!("\t{}", result.as_string());
        }
        Rule::solve => {
            let mut iter = line.into_inner();
            let mut p = parse_polynomial(iter.next().unwrap().into_inner());
            p.evaluate(&var_values);
            let mut variable = p.first_var().unwrap_or("".to_string());
            if variable.is_empty() {
                panic!("No variable to solve for");
            }
            if let Some(var) = iter.next() {
                variable = var.as_str().to_string();
            }
            let result = p.roots(&variable);
            for root in result {
                if root.len() == 1 {
                    println!("\t{}\t= {}", variable, root[0].as_string());
                } else if root.len() > 1 {
                    print!("\t{}\\t= {}", variable, root[0].as_string());
                    for ratio in &root[1..] {
                        if ratio.numerator.terms[0].coefficient >= 0.into() {
                            print!(" + ");
                        }
                        print!("{}", ratio.as_string());
                    }
                    println!();
                }
            }
        }
        Rule::EOI => (),
        _ => unreachable!(),
    }
}
\end{lstlisting}
